/**********************************************************
 * Example of defining metadata on the client in JavaScript
 * Used by metadataTests.js
 **********************************************************/
(function (testFns) {
    "use strict";

    testFns.metadataOnClient = {
        createDtoMetadataStore: createDtoMetadataStore,
        createProductMetadataStore: createProductMetadataStore,
        createEmployeeMetadataStore: createEmployeeMetadataStore,

        addCategoryType: addCategoryType,
        addCustomerDtoType: addCustomerDtoType,
        addLocationComplexType: addLocationComplexType,
        addOrderDtoType: addOrderDtoType,
        addOrderDetailDtoType: addOrderDetailDtoType,
        addProductDtoType: addProductDtoType,
        addProductType: addProductType,
        addSupplierType: addSupplierType
    };
    //////////////////////////////////////////

    // Convenience variables
    var DT = breeze.DataType;
    var Identity = breeze.AutoGeneratedKeyType.Identity;
    var Validator = breeze.Validator;
    var camelCaseConvention = breeze.NamingConvention.camelCase;

    // Breeze Labs: breeze.metadata.helper.js
    var helper = new breeze.config.MetadataHelper();

    // Helper convenience methods
    var addDataService      = helper.addDataService.bind(helper);
    var addTypeToStore      = helper.addTypeToStore.bind(helper);
    var setDefaultNamespace = helper.setDefaultNamespace.bind(helper);

    // Creates a metadataStore with 3 Northwind Product EntityTypes:
    // Product, Category, Supplier and a LocationComplexType
    function createProductMetadataStore(dataservice) {

        var store = createMetadataStore();

        addDataService(store, dataservice);

        setDefaultNamespace(testFns.northwindNamespace);

        // Add types in alphabetical order ... because we can
        addCategoryType(store);
        addLocationComplexType(store);
        addProductType(store);
        addSupplierType(store);

        return store;
    }

    //#region Category
    // A simple reference type
    function addCategoryType(store) {
        var et = {
            shortName: "Category",
            namespace: testFns.northwindNamespace,  // set by patchDefaults() in subsequent typeDefs
            autoGeneratedKeyType: Identity,         // default is None
            defaultResourceName: "Categories",

            dataProperties: {
                categoryID:   { dataType: DT.Int32, isPartOfKey: true },
                categoryName: { maxLength: 4000 }, // DT.String is the default DataType
                description:  { maxLength: 4000 },
                picture:      { dataType: DT.Binary, maxLength: 4000},
                rowVersion:   { dataType: DT.Int32, isNullable: false },
            }
        };

        return addTypeToStore(store, et);
    }
    //#endregion

    //#region Location ComplexType
    function addLocationComplexType(store) {
        var et = {
            shortName: "Location",
            isComplexType: true,

            dataProperties: {
                address:    { maxLength: 60 },
                city:       { maxLength: 15 },
                region:     { maxLength: 15 },
                postalCode: { maxLength: 10 },
                country:    { maxLength: 15 },
            }
        };

        return addTypeToStore(store, et);
    }

    //#endregion

    //#region Product
    function addProductType(store) {
        var et = {
            shortName: "Product",
            autoGeneratedKeyType: Identity,
            defaultResourceName: "Products",

            dataProperties: {
                productID:       { dataType: DT.Int32, isPartOfKey: true },
                productName:     { maxLength: 40, required: true },
                supplierID:      { dataType: DT.Int32, isNullable: false },
                categoryID:      { dataType: DT.Int32, isNullable: false },
                quantityPerUnit: { maxLength: 4000 },
                unitPrice:       { dataType: DT.Decimal },
                unitsInStock:    { dataType: DT.Int16 },
                unitsOnOrder:    { dataType: DT.Int16 },
                reorderLevel:    { dataType: DT.Int16 },
                discontinued:    { dataType: DT.Boolean, isNullable: false },
                discontinuedDate:{ dataType: DT.DateTime },
                rowVersion:      { dataType: DT.Int32, isNullable: false },
            },

            navigationProperties: {
                category: {
                    entityTypeName: "Category",
                    associationName: "Product_Category",
                    foreignKeyNames: ["categoryID"]
                },
                supplier: {
                    entityTypeName: "Supplier",
                    associationName: "Supplier_Products",
                    foreignKeyNames: ["supplierID"]
                },
            }
        };

        return addTypeToStore(store, et);
    }
    //#endregion

    //#region Supplier
    // Another simple reference type
    function addSupplierType(store) {
        var et = {
            shortName: "Supplier",
            autoGeneratedKeyType: Identity,
            defaultResourceName: "Suppliers",

            custom: {style: "bold", meaningOfLife: 42},

            dataProperties: {
                supplierID:   { dataType: DT.Int32, isPartOfKey: true },
                companyName:  { maxLength: 40, isNullable: false, custom: {uiHint:"big"} },
                contactName:  { maxLength: 30 },
                contactTitle: { maxLength: 30 },
                location:     { complexTypeName: "Location", isNullable: false },

                /* if didn't have Location ComplexType
                address:      { maxLength: 60 },
                city:         { maxLength: 15 },
                region:       { maxLength: 15 },
                postalCode:   { maxLength: 10 },
                country:      { maxLength: 15 },
                */

                // example of embedding a validator in the metadata
                phone:        { maxLength: 24 , validators: [ Validator.phone() ] },
                fax:          { maxLength: 24 },
                homePage:     { maxLength: 4000 },
                rowVersion:   { dataType: DT.Int32, isNullable: false },
            },

            navigationProperties: {
                products: {
                    entityTypeName: "Product",
                    isScalar: false,
                    associationName: "Supplier_Products",
                }
            }
        };

        return addTypeToStore(store, et);
    }
    //#endregion


    // Creates a metadataStore with NorthwindDto entity types:
    // Customer, Order, OrderDetail, Product
    function createDtoMetadataStore(dataservice) {

        var store = createMetadataStore();

        addDataService(store, dataservice);

        setDefaultNamespace(testFns.northwindDtoNamespace);

        // Add types in alphabetical order ... because we can
        addCustomerDtoType(store);
        addOrderDtoType(store);
        addOrderDetailDtoType(store);
        addProductDtoType(store);

        return store;
    }

    //#region CustomerDto
    function addCustomerDtoType(store) {
        var et = {
            shortName: "Customer",
            defaultResourceName: "Customers",

            dataProperties: {
                customerID:  { dataType: DT.Guid, isPartOfKey: true },
                companyName: { isNullable: false, maxLength: 40 },
                fragusIndex: { dataType: DT.Int32 },
                orderCount:  { dataType: DT.Int32 },
            },

            navigationProperties: {
                orders: {
                    entityTypeName: "Order",
                    isScalar: false,
                    associationName: "Order_Customer",
                    invForeignKeyNames: ["customerID"] // in server def; shouldn't be necessary
                }
            }
        };

        return addTypeToStore(store, et);
    }

    //#endregion

    //#region OrderDto
    function addOrderDtoType(store) {
        var et = {
            shortName: "Order",
            autoGeneratedKeyType: Identity,
            defaultResourceName: "Orders",

            dataProperties: {
                orderID:      { dataType: DT.Int32, isPartOfKey: true },
                customerID:   { dataType: DT.Guid },
                customerName: { maxLength: 40 },
                orderDate:    { dataType: DT.DateTime },
                requiredDate: { dataType: DT.DateTime }, 
                shippedDate:  { dataType: DT.DateTime },
                freight:      { dataType: DT.Decimal },
                rowVersion:   { dataType: DT.Int32, isNullable: false }
            },

            navigationProperties: {
                customer: {
                    entityTypeName: "Customer",
                    associationName: "Order_Customer",
                    foreignKeyNames: ["customerID"] 
                },
                orderDetails: {
                    entityTypeName: "OrderDetail",
                    isScalar: false,
                    associationName: "OrderDetail_Order",
                    invForeignKeyNames: ["orderID"] // in server def; shouldn't be necessary
                }
            }
        };

        return addTypeToStore(store, et);
    }

    //#endregion

    //#region OrderDetailDto
    function addOrderDetailDtoType(store) {
        var et = {
            shortName: "OrderDetail",
            defaultResourceName: "OrderDetails",

            dataProperties: {
                orderID:    { dataType: DT.Int32, isPartOfKey: true },
                productID:  { dataType: DT.Int32, isPartOfKey: true },

                unitPrice:  { dataType: DT.Decimal, isNullable: false },
                quantity:   { dataType: DT.Int16, isNullable: false },
                discount:   { dataType: DT.Single, isNullable: false },
                rowVersion: { dataType: DT.Int32, isNullable: false }
            },

            navigationProperties: {
                order: {
                    entityTypeName: "Order",
                    associationName: "OrderDetail_Order",
                    foreignKeyNames: ["orderID"]
                },
                product: {
                    entityTypeName: "Product",
                    associationName: "OrderDetail_Product", // not needed but server version has it
                    foreignKeyNames: ["productID"]
                }

            }
        };

        return addTypeToStore(store, et);
    }

    //#endregion

    //#region ProductDto
    function addProductDtoType(store) {
        var et = {
            shortName: "Product",
            autoGeneratedKeyType: Identity,
            defaultResourceName: "Products",

            dataProperties: {
                productID: { dataType: DT.Int32, isPartOfKey: true },
                productName: { maxLength: 40, isNullable: false },
                categoryID: { dataType: DT.Int32, isNullable: false },
                supplierID: { dataType: DT.Int32, isNullable: false },
            },

            navigationProperties: {
              category: {
                entityTypeName: "Category",
                associationName: "Product_Category",
                foreignKeyNames: ["categoryID"]
              },
              supplier: {
                entityTypeName: "Supplier",
                associationName: "Product_Supplier", // not needed but server version has it
                foreignKeyNames: ["supplierID"]
              }
          }
        };

        return addTypeToStore(store, et);
    }
    //#endregion

    //http://stackoverflow.com/questions/24172631/something-is-wrong-with-attaching-navigationproperties-when-done-in-different-or
    // Creates a metadataStore with 3 entity types:
    // Employee, DaySchedule, AttendanceDay
    function createEmployeeMetadataStore(dataservice) {

        var dayScheduleEntityName = 'DaySchedule';
        var employeeEntityName = 'Employee';
        var attendanceDayEntityName = 'AttendanceDay';

        var metadataStore = createMetadataStore();

        addDataService(metadataStore, dataservice);

        setDefaultNamespace(testFns.northwindDtoNamespace);

        // Add types in alphabetical order ... because we can
        addAttendanceDayType(metadataStore);
        addDayScheduleType(metadataStore);
        addEmployeeType(metadataStore);

        return metadataStore;


        //#region Employee
        function addEmployeeType(store) {
            var et = {
                name: employeeEntityName,
                autoGeneratedKeyType: Identity,
                dataProperties: {
                    id: { type: breeze.DataType.Int32 },
                },

                navigationProperties: {
                    schedules: { entityTypeName: dayScheduleEntityName, hasMany: true },
                    attendanceDays: { entityTypeName: attendanceDayEntityName, hasMany: true },
                }
            };

            return addTypeToStore(store, et);
        }

        //#endregion

        //#region DaySchedule
        function addDayScheduleType(store) {
            var et = {
                name: dayScheduleEntityName,
                autoGeneratedKeyType: Identity,
                dataProperties: {
                    id: { type: breeze.DataType.Int32 },
                    employeeId: { type: breeze.DataType.Int32 },
                },

                navigationProperties: {
                    employee: employeeEntityName,
                }
            };

            return addTypeToStore(store, et);
        }

        //#endregion

        //#region AttendanceDay
        function addAttendanceDayType(store) {
            var et = {
                name: attendanceDayEntityName,
                autoGeneratedKeyType: Identity,
                dataProperties: {
                    id: { type: breeze.DataType.Int32 },
                    employeeId: { type: breeze.DataType.Int32 },
                },

                navigationProperties: {
                    employee: employeeEntityName,
                }
            };

            return addTypeToStore(store, et);
        }

        //#endregion
    }



    //private helper methods

    function createMetadataStore() {
        return new breeze.MetadataStore({ namingConvention: camelCaseConvention });
    }


})(docCode.testFns);